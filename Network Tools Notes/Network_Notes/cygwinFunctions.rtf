{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\froman\fcharset0 Times New Roman;}{\f1\fswiss\fcharset0 Courier New;}{\f2\fswiss\fcharset0 Arial;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;}
{\*\generator Msftedit 5.41.15.1503;}\viewkind4\uc1\pard\keepn\sb100\sa100\kerning36\b\f0\fs48 http://gcc.gnu.org/onlinedocs/\par
\par
Compatibility\par
Compatibility with ANSI\par
\pard\sb100\sa100\kerning0\b0\fs24 The following functions are compatible with ANSI:\par
\pard\keepn\sb100\sa100\b\fs36 stdio\par
\pard\sb100\sa100\b0\fs24 clearerr, fclose, feof, ferror, fflush, fgetc, fgetpos, fgets, fopen, fprintf, fputc, fputs, fread, freopen, fscanf, fseek, fsetpos, ftell, fwrite, getc, getchar, gets, perror, printf, putc, putchar, puts, remove, rename, rewind, scanf, setbuf, setvbuf, sprintf, sscanf, tmpfile, tmpnam, vfprintf, ungetc, vprintf, vsprintf, \par
\pard\keepn\sb100\sa100\b\fs36 string\par
\pard\sb100\sa100\b0\fs24 memchr, memcmp, memcpy, memmove, memset, strcat, strchr, strcmp, strcoll, strcpy, strcspn, strerror, strlen, strncat, strncmp, strncpy, strpbrk, strrchr, strspn, strstr, strtok, strxfrm \par
\pard\keepn\sb100\sa100\b\fs36 stdlib\par
\pard\sb100\sa100\b0\fs24 abort, abs, assert, atexit, atof, atoi, atol, bsearch, calloc, div, exit, free, getenv, labs, ldiv, longjmp, malloc, mblen, mbstowcs, mbtowc, qsort, rand, realloc, setjmp, srand, strtod, strtol, strtoul, system, wcstombs, wctomb \par
\pard\keepn\sb100\sa100\b\fs36 time\par
\pard\sb100\sa100\b0\fs24 asctime, gmtime, localtime, time, clock, ctime, difftime, mktime, strftime \par
\pard\keepn\sb100\sa100\b\fs36 signals\par
\pard\sb100\sa100\b0\fs24 raise, signal \par
\pard\keepn\sb100\sa100\b\fs36 ctype\par
\pard\sb100\sa100\b0\fs24 isalnum, isalpha, iscntrl, isdigit, isgraph, islower, isprint, ispunct, isspace, isupper, isxdigit, tolower, toupper \par
\pard\keepn\sb100\sa100\b\fs36 math\par
\pard\sb100\sa100\b0\fs24 acos, asin, atan, atan2, ceil, cos, cosh, exp, fabs, floor, fmod, frexp, ldexp, log, log10, modf, pow, sin, sinh, sqrt, tan, tanh \par
\pard\keepn\sb100\sa100\b\fs36 misc\par
\pard\sb100\sa100\b0\fs24 localeconv, setlocale, va_arg, va_end, va_start \par
\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 Compatibility with POSIX.1\par
\pard\sb100\sa100\kerning0\b0\fs24 The following functions are compatible with POSIX.1:\par
\pard\keepn\sb100\sa100\b\fs36 Process Primitives (Section 3)\par
\pard\sb100\sa100\b0\fs24 fork, execl, execle, execlp, execv, execve, execvp, wait, waitpid, _exit, kill, sigemptyset, sigfillset, sigaddset, sigdelset, sigismember, sigaction, pthread_sigmask, sigprocmask, sigpending, sigsuspend, alarm, pause, sleep, pthread_kill, pthread_sigmask \par
\pard\keepn\sb100\sa100\b\fs36 Process Environment (Section 4)\par
\pard\sb100\sa100\b0\fs24 getpid, getppid, getuid, geteuid, getgid, getegid, setuid, setgid, getgroups, getlogin, getpgrp, setsid, setpgid, uname, time, times, getenv, ctermid, ttyname, isatty, sysconf \par
\pard\keepn\sb100\sa100\b\fs36 Files and Directories (Section 5)\par
\pard\sb100\sa100\b0\fs24 opendir, readdir, rewinddir, closedir, chdir, getcwd, open, creat, umask, link, mkdir, unlink, rmdir, rename, stat, fstat, access, chmod, fchmod, chown, utime, ftruncate, pathconf, fpathconf \par
\pard\keepn\sb100\sa100\b\fs36 Input and Output Primitives (Section 6)\par
\pard\sb100\sa100\b0\fs24 pipe, dup, dup2, close, read, write, fcntl, lseek, fsync \par
\pard\keepn\sb100\sa100\b\fs36 Device- and Class-Specific Functions (Section 7)\par
\pard\sb100\sa100\b0\fs24 cfgetispeed, cfgetospeed, cfsetispeed, cfsetospeed, tcdrain, tcflow, tcflush, tcgetattr, tcgetpgrp, tcsendbreak, tcsetattr, tcsetpgrp \par
\pard\keepn\sb100\sa100\b\fs36 Language-Specific Services for the C Programming Language (Section 8)\par
\pard\sb100\sa100\b0\fs24 abort, exit, fclose, fdopen, fflush, fgetc, fgets, fileno, fopen, fprintf, fputc, fputs, fread, freopen, fscanf, fseek, ftell, fwrite, getc, getchar, gets, perror, printf, putc, putchar, puts, remove, rewind, scanf, setlocale, siglongjmp, sigsetjmp, tmpfile, tmpnam, tzset \par
\pard\keepn\sb100\sa100\b\fs36 System Databases (Section 9)\par
\pard\sb100\sa100\b0\fs24 getgrgid, getgrnam, getpwnam, getpwuid \par
\pard\keepn\sb100\sa100\b\fs36 Synchronization (Section 11)\par
\pard\sb100\sa100\b0\fs24 sem_init, sem_destroy, sem_wait, sem_trywait, sem_post, pthread_mutex_init, pthread_mutex_destroy, pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock \par
\pard\keepn\sb100\sa100\b\fs36 Memory Management (Section 12)\par
\pard\sb100\sa100\b0\fs24 mmap, mprotect, msync, munmap \par
\pard\keepn\sb100\sa100\b\fs36 Thread Management (Section 16)\par
\pard\sb100\sa100\b0\fs24 pthread_attr_init, pthread_attr_destroy, pthread_attr_setstacksize, pthread_attr_getstacksize, pthread_create, pthread_exit, pthread_self, pthread_equal \par
\pard\keepn\sb100\sa100\b\fs36 Thread-Specific Data Functions (Section 17)\par
\pard\sb100\sa100\b0\fs24 pthread_key_create, pthread_setspecific, pthread_getspecific, pthread_key_delete \par
\pard\keepn\sb100\sa100\b\fs36 Implementation Details\par
\pard\sb100\sa100\b0\fs24 setuid and setgid always return ENOSYS.\par
link will copy the file if it can't implement a true symbolic link. Currently, symbolic links work, if at all, only under Windows NT.\par
chown always returns zero.\par
fcntl doesn't support F_GETLK - it returns -1 and sets errno to ENOSYS.\par
lseek only works properly on binary files.\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 Compatibility with Miscellaneous Other Standards\par
\pard\sb100\sa100\kerning0\b0\fs24 The following functions are compatible with miscellaneous other standards:\par
\pard\keepn\sb100\sa100\b\fs36 Networking\par
\pard\sb100\sa100\b0\fs24 (Standardized by POSIX 1.g, which is probably still in draft?)\par
accept, bind, connect, getdomainname, gethostbyaddr, gethostbyname, getpeername, getprotobyname, getprotobynumber, getservbyname, getservbyport, getsockname, getsockopt, herror, htonl, htons, inet_addr, inet_makeaddr, inet_netof, inet_ntoa, listen, ntohl, ntohs, rcmd, recv, recvfrom, rexec, rresvport, send, sendto, setsockopt, shutdown, socket, socketpair\par
Of these networking calls, rexec, rcmd and rresvport are implemented in MS IP stack but may not be implemented in other vendors' stacks. \par
\pard\keepn\sb100\sa100\b\fs36 Other\par
\pard\sb100\sa100\b0\fs24 chroot, closelog, cwait, dlclose, dlerror, dlfork, dlopen, dlsym, endgrent, ffs, fstatfs, ftime, get_osfhandle, getdtablesize, getgrent, gethostname, getitimer, getmntent, getpagesize, getpgid, getpwent, gettimeofday, grantpt, initgroups, ioctl, killpg, login, logout, lstat, mknod, memccpy, nice, openlog, pclose, popen, ptsname, putenv, random, readv, realpath, regfree, rexec, select, setegid setenv, seterrno, seteuid, setitimer, setmntent, setmode, setpassent, setpgrp, setpwent, settimeofday, sexecl, sexecle, sexeclp, sexeclpe, sexeclpe, sexecp, sexecv, sexecve, sexecvpe, sigpause, spawnl, spawnle, spawnlp, spawnlpe, spawnv, spawnve, spawnvp, spawnvpe, srandom, statfs, strsignal, strtosigno, swab, syslog, timezone, truncate, ttyslot, unlockpt, unsetenv, usleep, utimes, vfork, vhangup, wait3, wait4, wcscmp, wcslen, wprintf, writev \par
\pard\keepn\sb100\sa100\b\fs36 Implementation Notes\par
\pard\sb100\sa100\b0\fs24 initgroups does nothing\par
chroot, mknod, settimeofday, and vhangup always return -1 and sets errno to ENOSYS.\par
nice allows Cygwin programs to alter their current runtime priority through the use of its incr argument. Cygwin processes can be set to IDLE_PRIORITY_CLASS, NORMAL_PRIORITY_CLASS, HIGH_PRIORITY_CLASS, or REALTIME_PRIORITY_CLASS with the nice call. NORMAL_PRIORITY_CLASS is the default. If you pass a positive number to nice(), then the priority level will decrease by one (within the above list of priorities). A negative number would make it increase by one. It is not possible to change it by more than one at a time without making repeated calls. An increment above REALTIME_PRIORITY_CLASS results in the process staying at that priority. Likewise, a decrement to IDLE_PRIORITY_CLASS has it stay at that priority. Note that in the Win32 API, there are 32 priorities. So currently we only give access to four of these through nice.\par
seteuid and setegid always return 0 and set errno to ENOSYS.\par
vfork just calls fork\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 Cygwin Functions\par
\pard\sb100\sa100\kerning0\b0\fs24 These functions are specific to Cygwin itself, and probably won't be found anywhere else. \par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_attach_handle_to_fd\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" int cygwin_attach_handle_to_fd(char *\i name\i0 , int \i fd\i0 , HANDLE \i handle\i0 , int \i bin\i0 , int \i access\i0 ); \par
This function can be used to turn a Win32 "handle" into a posix-style file handle. \i fd\i0  may be -1 to make cygwin allocate a handle; the actual handle is returned in all cases.\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_conv_to_full_posix_path\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" void cygwin_conv_to_full_posix_path(const char *\i path\i0 , char *\i posix_path\i0 ); \par
Converts a Win32 path to a POSIX path. If \i path\i0  is already a POSIX path, leaves it alone. If \i path\i0  is relative, then \i posix_path\i0  will be converted to an absolute path. Note that \i posix_path\i0  must point to a buffer of sufficient size; use MAX_PATH if needed.\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_conv_to_full_posix_path\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" void cygwin_conv_to_full_posix_path(const char *\i path\i0 , char *\i posix_path\i0 ); \par
Converts a Win32 path to a POSIX path. If \i path\i0  is already a POSIX path, leaves it alone. If \i path\i0  is relative, then \i posix_path\i0  will be converted to an absolute path. Note that \i posix_path\i0  must point to a buffer of sufficient size; use MAX_PATH if needed.\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_conv_to_full_win32_path\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" void cygwin_conv_to_full_win32_path(const char *\i path\i0 , char *\i win32_path\i0 ); \par
Converts a POSIX path to a Win32 path. If \i path\i0  is already a Win32 path, leaves it alone. If \i path\i0  is relative, then \i win32_path\i0  will be converted to an absolute path. Note that \i win32_path\i0  must point to a buffer of sufficient size; use MAX_PATH if needed.\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_conv_to_posix_path\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" void cygwin_conv_to_posix_path(const char *\i path\i0 , char *\i posix_path\i0 ); \par
Converts a Win32 path to a POSIX path. If \i path\i0  is already a POSIX path, leaves it alone. If \i path\i0  is relative, then \i posix_path\i0  will also be relative. Note that \i posix_path\i0  must point to a buffer of sufficient size; use MAX_PATH if needed.\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_conv_to_win32_path\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" void cygwin_conv_to_win32_path(const char *\i path\i0 , char *\i win32_path\i0 ); \par
Converts a POSIX path to a Win32 path. If \i path\i0  is already a Win32 path, leaves it alone. If \i path\i0  is relative, then \i win32_path\i0  will also be relative. Note that \i win32_path\i0  must point to a buffer of sufficient size; use MAX_PATH if needed.\par
\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_detach_dll\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" void cygwin_detach_dll(int \i dll_index\i0 );\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_getshared\par
\pard\sb100\sa100\kerning0\b0\fs24\par
shared_info * cygwin_getshared(void); \par
Returns a pointer to an internal Cygwin memory structure containing shared information used by cooperating cygwin processes. This function is intended for use only by "system" programs like mount and ps.\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_internal\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" DWORD cygwin_internal(cygwin_getinfo_types \i t\i0 , \i ...\i0 ); \par
This function gives you access to various internal data and functions. It takes two arguments. The first argument is a type from the 'cygwin_getinfo_types' enum. The second is an optional pointer.\par
Stay away unless you know what you're doing.\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_posix_path_list_p\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" int posix_path_list_p(const char *\i path\i0 ); \par
This function tells you if the supplied \i path\i0  is a POSIX-style path (i.e. posix names, forward slashes, colon delimiters) or a Win32-style path (drive letters, reverse slashes, semicolon delimiters. The return value is true if the path is a POSIX path. Note that "_p" means "predicate", a lisp term meaning that the function tells you something about the parameter.\par
Rather than use a mode to say what the "proper" path list format is, we allow any, and give apps the tools they need to convert between the two. If a ';' is present in the path list it's a Win32 path list. Otherwise, if the first path begins with [letter]: (in which case it can be the only element since if it wasn't a ';' would be present) it's a Win32 path list. Otherwise, it's a POSIX path list.\par
Rather than use a mode to say what the "proper" path list format is, we allow any, and give apps the tools they need to convert between the two. If a ';' is present in the path list it's a Win32 path list. Otherwise, if the first path begins with [letter]: (in which case it can be the only element since if it wasn't a ';' would be present) it's a Win32 path list. Otherwise, it's a POSIX path list.\par
\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_posix_to_win32_path_list\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" void cygwin_posix_to_win32_path_list(const char *\i posix\i0 , char *\i win32\i0 ); \par
Given a POSIX path-style string (i.e. /foo:/bar) convert it to the equivalent Win32 path-style string (i.e. d:\\;e:\\bar). \i win32\i0  must point to a sufficiently large buffer.\par
\par
\b Example 1. Example use of cygwin_posix_to_win32_path_list\b0\par
\trowd\trgaph10\trleft-10\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clvertalc\clcfpat2\clcbpat2\cellx9350\pard\intbl\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\f1\fs20 char *_epath;\par
char *_win32epath;\par
_epath = _win32epath = getenv (NAME);\par
/* If we have a POSIX path list, convert to win32 path list */\par
if (_epath != NULL && *_epath != 0\par
    && cygwin_posix_path_list_p (_epath))\par
  \{\par
    _win32epath = (char *) xmalloc\par
      (cygwin_posix_to_win32_path_list_buf_size (_epath));\par
    cygwin_posix_to_win32_path_list (_epath, _win32epath);\par
    \}\cell\row\pard\sb100\sa100\f0\fs24\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_posix_to_win32_path_list_buf_size\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" int cygwin_posix_to_win32_path_list_buf_size(const char *\i path_list\i0 ); \par
Returns the number of bytes needed to hold the result of calling {\field{\*\fldinst{HYPERLINK "func-cygwin-posix-to-win32-path-list.html"}}{\fldrslt{\cf1\ul cygwin_posix_to_win32_path_list}}}\cf0\ulnone\f0\fs24 .\par
\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_split_path\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" void cygwin_split_path(const char * \i path\i0 , char * \i dir\i0 , char * \i file\i0 ); \par
Split a path into the directory and the file portions. Both \i dir\i0  and \i file\i0  are expected to point to buffers of sufficient size. \par
\par
\b Example 2. Example use of cygwin_split_path\b0\par
\trowd\trgaph10\trleft-10\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clvertalc\clcfpat2\clcbpat2\cellx9350\pard\intbl\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\f1\fs20 char dir[200], file[100];\par
cygwin_split_path("c:/foo/bar.c", dir, file);\par
printf("dir=%s, file=%s\\n", dir, file);\cell\row\pard\sb100\sa100\f0\fs24\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_stackdump\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" void cygwin_stackdump(void); \par
Outputs a stackdump to stderr from the called location.\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_win32_to_posix_path_list\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" void cygwin_win32_to_posix_path_list(const char *\i win32\i0 , char *\i posix\i0 ); \par
Given a Win32 path-style string (i.e. d:\\;e:\\bar) convert it to the equivalent POSIX path-style string (i.e. /foo:/bar). \i posix\i0  must point to a sufficiently large buffer. See also {\field{\*\fldinst{HYPERLINK "func-cygwin-win32-to-posix-path-list-buf-size.html"}}{\fldrslt{\cf1\ul cygwin_win32_to_posix_path_list_buf_size}}}\cf0\ulnone\f0\fs24\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_win32_to_posix_path_list_buf_size\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" int cygwin_win32_to_posix_path_list_buf_size(const char *\i path_list\i0 ); \par
Tells you how many bytes are needed for the results of {\field{\*\fldinst{HYPERLINK "func-cygwin-win32-to-posix-path-list.html"}}{\fldrslt{\cf1\ul cygwin_win32_to_posix_path_list}}}\cf0\ulnone\f0\fs24 .\par
\par
\pard\keepn\sb100\sa100\kerning36\b\fs48 cygwin_winpid_to_pid\par
\pard\sb100\sa100\kerning0\b0\fs24\par
extern "C" pid_t cygwin_winpid_to_pid (int \i winpid\i0 ); \par
Given a windows pid, converts to the corresponding Cygwin pid, if any. Returns -1 if windows pid does not correspond to a cygwin pid.\par
\par
\b Example 3. Example use of cygwin_winpid_to_pid\b0\par
\trowd\trgaph10\trleft-10\trpaddl10\trpaddr10\trpaddfl3\trpaddfr3
\clvertalc\clcfpat2\clcbpat2\cellx9350\pard\intbl\tx0\tx959\tx1918\tx2877\tx3836\tx4795\tx5754\tx6713\tx7672\tx8631\f1\fs20       extern "C" cygwin_winpid_to_pid (int winpid);\par
      pid_t mypid;\par
      mypid = cygwin_winpid_to_pid (windows_pid);\par
    \cell\row\pard\sb100\sa100\f0\fs24\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\pard\f2\fs20\par
}
 